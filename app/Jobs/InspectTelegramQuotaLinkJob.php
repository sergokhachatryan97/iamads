<?php

namespace App\Jobs;

use App\Models\ClientServiceQuota;
use App\Services\Telegram\TelegramInspector;
use App\Services\Telegram\TelegramExecutionPolicy;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class InspectTelegramQuotaLinkJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 5;
    public array $backoff = [10, 30, 60, 120, 300];

    public function __construct(public int $quotaId) {}

    public function handle(TelegramInspector $inspector): void
    {
        // 1) Atomically "claim" the quota (with TTL to recover stuck claims)
        $claimTtlMinutes = 10;

        $claimed = ClientServiceQuota::query()
            ->whereKey($this->quotaId)
            ->where('expires_at', '>', now())
            ->where(function ($q) use ($claimTtlMinutes) {
                $q->whereNull('provider_sending_at')
                    ->orWhere('provider_sending_at', '<', now()->subMinutes($claimTtlMinutes));
            })
            ->update(['provider_sending_at' => now()]);

        if ($claimed === 0) {
            return;
        }

        $quota = null;

        try {
            $quota = ClientServiceQuota::query()
                ->with(['service'])
                ->find($this->quotaId);

            if (!$quota) {
                Log::warning('Quota not found after claim (unexpected)', ['quota_id' => $this->quotaId]);
                return;
            }

            // Expired -> nothing to do
            if ($quota->expires_at?->isPast()) {
                return;
            }

            // Ensure service is loaded
            if (!$quota->service) {
                $providerPayload = $quota->provider_payload ?? [];
                $providerPayload['telegram'] = [
                    'ok' => false,
                    'error_code' => 'SERVICE_NOT_FOUND',
                    'error' => 'Service not found for quota',
                ];

                $quota->update([
                    'provider_last_error' => 'Service not found for quota',
                    'provider_last_error_at' => now(),
                    'provider_payload' => $providerPayload,
                ]);

                return;
            }

            // If quota has no work left -> do not process
            $totalQuantity = (int) ($quota->quantity_left ?? $quota->orders_left ?? 0);
            if ($totalQuantity <= 0) {
                $providerPayload = $quota->provider_payload ?? [];
                $providerPayload['telegram'] = $providerPayload['telegram'] ?? [
                    'ok' => false,
                    'error_code' => 'NO_WORK',
                    'error' => 'Quota has no remaining quantity/orders',
                ];

                $quota->update([
                    'provider_last_error' => null,
                    'provider_last_error_at' => null,
                    'provider_payload' => $providerPayload,
                ]);

                return;
            }

            // 2) If inspection already successful -> no dispatch needed (pull mode)
            // In pull mode, tasks are generated by telegram:tasks:generate command
            $providerPayload = $quota->provider_payload ?? [];
            $existingInspection = $providerPayload['telegram'] ?? null;

            if (is_array($existingInspection) && ($existingInspection['ok'] ?? false) === true) {
                // Pull mode: no dispatch, tasks will be generated by telegram:tasks:generate
                return;
            }

            // 3) Inspect the link
            $inspectionResult = $inspector->inspect($quota->link ?? '');

            // Store inspection result
            $providerPayload['telegram'] = $inspectionResult;

            // 4) Extract and store post_id for post-related services (react, comment, view)
            $parsed = $inspectionResult['parsed'] ?? [];
            if (isset($parsed['post_id']) && isset($parsed['kind']) && $parsed['kind'] === 'public_post') {
                $providerPayload['telegram']['post_id'] = (int) $parsed['post_id'];
            }

            // 5) Handle inspection failure
            if (!($inspectionResult['ok'] ?? false)) {
                $errorCode = (string) ($inspectionResult['error_code'] ?? 'UNKNOWN_ERROR');
                $errorMessage = (string) ($inspectionResult['error'] ?? 'Unknown error during Telegram link inspection');

                $quota->update([
                    'provider_last_error' => $errorMessage,
                    'provider_last_error_at' => now(),
                    'provider_payload' => $providerPayload,
                ]);

                if ($this->isRetryableInspectionError($errorCode)) {
                    Log::warning('Telegram link inspection transient failure for quota; will retry', [
                        'quota_id' => $this->quotaId,
                        'error_code' => $errorCode,
                        'error' => $errorMessage,
                    ]);

                    // Throw -> queue retry/backoff
                    throw new \RuntimeException("Retryable inspection error: {$errorCode} - {$errorMessage}");
                }

                Log::info('Telegram link inspection failed for quota (non-retryable)', [
                    'quota_id' => $this->quotaId,
                    'error_code' => $errorCode,
                    'error' => $errorMessage,
                ]);

                return;
            }

            // 6) Success: Calculate execution metadata
            $serviceType = $quota->service->service_type ?? 'default';
            $linkType = TelegramExecutionPolicy::linkTypeFromInspection($inspectionResult);
            $policy = TelegramExecutionPolicy::policyFor($serviceType, $linkType);

            if (!$policy || $linkType === 'unknown') {
                $quota->update([
                    'provider_last_error' => "No execution policy for service type '{$serviceType}' and link type '{$linkType}'",
                    'provider_last_error_at' => now(),
                    'provider_payload' => $providerPayload,
                ]);

                Log::warning('No execution policy found for quota', [
                    'quota_id' => $this->quotaId,
                    'service_type' => $serviceType,
                    'link_type' => $linkType,
                ]);

                return;
            }

            // perCall always 1 for quotas (one account per step)
            $perCall = 1;
            $intervalSeconds = (int) ($policy['interval_seconds'] ?? 60);

            $stepsTotal = $totalQuantity; // IMPORTANT: exactly remaining quantity/orders
            $etaSeconds = $stepsTotal * max(1, $intervalSeconds);
            $etaAt = now()->addSeconds($etaSeconds);

            $providerPayload['execution_meta'] = [
                'subject' => ['type' => 'quota', 'id' => $quota->id],
                'service_type' => $serviceType,
                'link_type' => $linkType,
                'action' => $policy['action'],
                'interval_seconds' => $intervalSeconds,
                'per_call' => $perCall,
                'steps_total' => $stepsTotal,
                'eta_seconds' => $etaSeconds,
                'eta_at' => $etaAt->toDateTimeString(),
                'next_run_at' => now()->toDateTimeString(),
            ];

            $quota->update([
                'provider_last_error' => null,
                'provider_last_error_at' => null,
                'provider_payload' => $providerPayload,
            ]);

            Log::info('Telegram quota link inspection OK, execution meta saved', [
                'quota_id' => $this->quotaId,
                'service_type' => $serviceType,
                'link_type' => $linkType,
                'action' => $policy['action'] ?? null,
                'steps_total' => $stepsTotal,
            ]);

            // Pull mode: no dispatch, tasks will be generated by telegram:tasks:generate
        } finally {
            // Always release claim (even on exceptions)
            if ($quota) {
                $quota->update(['provider_sending_at' => null]);
            } else {
                ClientServiceQuota::query()
                    ->whereKey($this->quotaId)
                    ->update(['provider_sending_at' => null]);
            }
        }
    }

    public function failed(Throwable $exception): void
    {
        $quota = ClientServiceQuota::query()->find($this->quotaId);

        if ($quota) {
            $quota->update([
                'provider_last_error' => $exception->getMessage(),
                'provider_last_error_at' => now(),
                'provider_sending_at' => null,
            ]);
        }

        Log::error('InspectTelegramQuotaLinkJob failed', [
            'quota_id' => $this->quotaId,
            'exception' => $exception->getMessage(),
        ]);
    }

    private function isRetryableInspectionError(string $errorCode): bool
    {
        $errorCode = strtoupper(trim($errorCode));

        // Retry only truly transient issues
        return in_array($errorCode, [
            'REQUEST_FAILED',
            'INVALID_RESPONSE',
            'UNKNOWN_ERROR',
            'MTPROTO_ERROR',
            'MTPROTO_INIT_FAILED',
        ], true);
    }
}
