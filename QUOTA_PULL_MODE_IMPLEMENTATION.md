# Quota Pull Mode Implementation

## Overview

Implemented pull-provider architecture for `ClientServiceQuota` that reuses the unified `telegram_tasks` table and existing pull endpoints. Quotas now generate tasks that providers pull via `/api/provider/telegram/tasks/pull` and report results via `/api/provider/telegram/tasks/report`.

## Changes Summary

### 1. Database Migration

**`database/migrations/2026_01_21_153744_add_subject_to_telegram_tasks_table.php`**
- Made `order_id` nullable to support quotas
- Added `subject_type` and `subject_id` columns for polymorphic relation
- Added index on `(subject_type, subject_id)`

### 2. Model Updates

**`app/Models/TelegramTask.php`**
- Added `subject_type` and `subject_id` to `$fillable`
- Added `subject()` morphTo relation
- Kept `order()` relation for backward compatibility

### 3. Service Updates

**`app/Services/Telegram/TelegramTaskService.php`**

#### New Methods:

1. **`generateQuotaTasks($maxTasks)`** - Phase 3 of `generateTasks()`
   - Finds eligible quotas: `expires_at > now`, counters > 0, inspection ok, `next_run_at <= now`
   - Filters in PHP after DB-level filtering
   - Calls `generateTaskForQuota()` for each eligible quota

2. **`generateTaskForQuota($quota)`** - Generates single quota task
   - Handles posts snapshot for last-N-post quotas
   - Selects account with reserve claim
   - Creates `TelegramTask` with `subject_type=ClientServiceQuota`
   - Advances `execution_meta.next_run_at`

3. **`getPostIdForQuota($quota, $parsed, $action)`** - Handles posts snapshot
   - Checks if snapshot exists and is fresh (TTL configurable, default 24h)
   - Refreshes snapshot if stale (placeholder implementation)
   - Uses round-robin cursor to select next post_id
   - Returns `post_id` or `false` if snapshot unavailable

4. **`refreshPostsSnapshot($quota, $parsed)`** - Placeholder for posts fetching
   - Returns `false` (not implemented yet)
   - TODO: Implement via TelegramInspector or provider API

5. **`selectAccountWithReserveForQuota(...)`** - Account selection for quotas
   - Reuses same two-phase claim logic as orders
   - Uses `reserveClaim()` (lock only, no cap/cooldown consumption)

6. **`handleQuotaTaskReport(...)`** - Handles quota task reports
   - Commits claim on success (consumes cap/cooldown)
   - Rolls back reserve on failure (releases lock only)
   - Updates quota counters:
     - `quantity_left`: decrement by `per_call`
     - `orders_left`: decrement by 1
   - Updates `execution_meta.next_run_at` for retries
   - Idempotent: checks if task already finalized

#### Updated Methods:

1. **`generateTasks()`** - Now has 3 phases:
   - Phase 1: Orders
   - Phase 2: Unsubscribe tasks
   - Phase 3: Quotas (NEW)

2. **`reportTaskResult()`** - Routes to quota handler
   - Detects quota vs order via `$task->subject`
   - Calls `handleQuotaTaskReport()` for quotas
   - Existing order logic unchanged

3. **`generateTaskForOrder()`** - Sets subject for backward compatibility
   - Sets both `order_id` and `subject_type/subject_id`

4. **`leaseTasks()`** - Includes subject info in response
   - Adds `subject_type` and `subject_id` to leased task payload
   - Keeps `order_id` for backward compatibility

### 4. Job Updates

**`app/Jobs/InspectTelegramQuotaLinkJob.php`**
- Removed `ProcessClientServiceQuotaJob::dispatch()` calls
- In pull mode, inspection completes and tasks are generated by `telegram:tasks:generate`

### 5. Configuration

**`config/telegram.php`**
- Added `quota.posts_snapshot_ttl_hours` (default: 24)

**`app/Console/Commands/GenerateTelegramTasks.php`**
- Updated description to mention quotas

## Eligibility Rules

Quotas are eligible for task generation when:
- ✅ `expires_at > now()` (not expired)
- ✅ `quantity_left > 0` OR `orders_left > 0` (has remaining work)
- ✅ `provider_payload['telegram']['ok'] === true` (inspection successful)
- ✅ `provider_payload['execution_meta']` exists (execution metadata present)
- ✅ `execution_meta['next_run_at'] <= now()` (or missing/invalid)

## Posts Snapshot Logic

For last-N-post quotas (view/react/comment actions):

1. **Snapshot Structure:**
   ```php
   provider_payload['telegram']['posts_snapshot'] = [
       'fetched_at' => '2026-01-21 12:00:00',
       'post_ids' => [123, 456, 789, ...]
   ]
   ```

2. **Cursor for Round-Robin:**
   ```php
   provider_payload['quota_cursor'] = [
       'post_index' => 0  // Advances on each task generation
   ]
   ```

3. **Refresh Logic:**
   - If snapshot missing or stale (> TTL), refresh via `refreshPostsSnapshot()`
   - If refresh fails, set error and skip quota until next retry
   - If snapshot empty, skip quota

4. **Post Selection:**
   - Uses cursor to select next post_id (round-robin)
   - Wraps to 0 when index >= count
   - Advances cursor after task creation

## Two-Phase Claim Semantics

Same as orders:
- **RESERVE** (task generation): Sets short lock, checks state/dedupe, NO cap/cooldown consumption
- **COMMIT** (success report): Consumes cooldown, cap, sets state, releases lock
- **ROLLBACK** (failure report): Releases lock only, NO cap/cooldown rollback

## Counter Decrement Logic

- **If `quantity_left` not null:** Decrement by `per_call` (always 1 for quotas)
- **Else if `orders_left` not null:** Decrement by 1
- **Clamp at >= 0:** Never goes negative

## Idempotency

- **Task finalization check:** If task already `DONE`/`FAILED`, ignore duplicate reports
- **Counter updates:** Use atomic DB updates to prevent double-decrement
- **Claim commit:** Only commits if task not already finalized

## Legacy Push Mode

- **`ProcessClientServiceQuotaJob`** - No longer dispatched (can be deleted or feature-flagged)
- **`InspectTelegramQuotaLinkJob`** - Still runs for inspection, but doesn't dispatch processing
- **`ProviderClient->executeTelegramQuotaStep()`** - Deprecated (unused in pull mode)

## Testing Checklist

- [ ] Quota eligibility by `expires_at` and `next_run_at`
- [ ] Posts snapshot refresh and cursor logic
- [ ] Report idempotency (duplicate report does not double-decrement)
- [ ] Commit/rollback claim called correctly for quota tasks
- [ ] Counter decrement logic (quantity_left vs orders_left)
- [ ] Account selection with reserve claim
- [ ] Task generation respects `next_run_at` gating

## Notes

- **Posts snapshot fetching:** Currently a placeholder (`refreshPostsSnapshot()` returns `false`). Needs implementation via TelegramInspector or provider API.
- **Backward compatibility:** `order_id` is kept for existing tasks, but new tasks also set `subject_type/subject_id`.
- **Unified table:** All tasks (orders, quotas, unsubscribe) use the same `telegram_tasks` table.
- **Provider API:** No changes needed - provider pulls from same endpoint, receives `subject_type/subject_id` in payload.

